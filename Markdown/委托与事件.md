## 委托

---

### 委托有什么用？

1. 将函数作为函数的参数进行传递
2. 声明事件并用来注册

### 强类型委托

```C#
Action<T1>
Func<T1, TResult>
```

### 委托的弊端：

- 调用委托时，如果其中的一个委托报错，则后面的不会被调用；

- 只有最后一个的返回值才会作为委托的返回值；

- 因为是数组，所以remove 的复杂度是O(n)；

- 线程不安全。

### 委托为什么不等于函数指针（C++ 中的）？

- 委托可以“指向”多个函数；
- 委托可以指向同一个函数多次；
- 函数是包含在类中的，所以函数引用也包含了所在对象的信息；而C/C++的函数指针只是函数的入口地址。

### 为什么不推荐使用接口代替委托：

1. 使用接口非常不灵活，比如使用 LINQ，要频繁传入各种形式的函数，且必须有类去实现接口
2. 传递接口对象本质上是传递类的引用，那么就有可能会将类的其他公共成员也暴露出来，引出不必要的麻烦
3. 无法使用多播委托与事件提供的各种功能，比如添加与删除
4. 类的方法是封装好的，而使用匿名委托可以随处声明，并使用当前作用域可访问的所有变量
5. 内置的强类型委托等充分提供了各种常见形式的委托类型，没有必要自己写大量接口



## 事件

---

### 事件的本质：

事件说白了是C#提供的语法糖，效果是：

1．将委托以私有变量的形式封装在类内，不让外面访问；

2．对于委托进行了封装，从而定义add与remove方法；

3．在add与remove中通过互锁的方式提供了线程安全性。

### 事件的目的：

希望一个类的某些成员在发生变化时能够被外界观测到

- `CollectionChange`
- `TextChanged`

标准的 .NET 事件模式

```C#
delegate EventHander(object sender, EventArgs e)
public class EventArgs
Button.Click
TextBox.TextChanged
```

推荐的命名规范

名词 + 动词（被动形式）

```C#
CollectionChanged
EventRaised
PropertyChanged
```

注册事件时命名规范

```C#
OnEventRaised
OnPropertyChanged
RaisePropertyChange
```

